Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.
Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.
Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.
Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.
Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.
Unfortunately, it will not work reliably in a platform independent way when implemented in Java, without additional synchronization.
When implemented in other languages, such as C++, it depends on the memory model of the processor, the reorderings performed by the compiler and the interaction between the compiler and the synchronization library.
Since none of these are specified in a language such as C++, little can be said about the situations in which it will work.
Explicit memory barriers can be used to make it work in C++, but these barriers are not available in Java.